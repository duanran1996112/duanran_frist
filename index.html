<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div class="html">
        行级元素 inline: span a em strong br
        块级元素 block: div h1~6 p ul li ol　

        h5新标签: 
                 非主体: header footer hgroup address
                 主体: article section nav aside
                 非结构性标签: audio video canvas svg

        audio video:
        　　　　　　　自动播放: autoplay 
                     播放: play
                     暂停: pause
                     已经播放时间: currentTine
                     视频的总时长: duration
                     进度条: controls
                     音量: volume
                     播放速度: playbackRate

        canvas: 
                使用canvas
                var canvas =document.getElementById('myCanvas');
                var ctx = canvas.getContext('2d');

                绘制线段: ctx.moveTo(xxx, xxx)　ctx.lineTo(xxx, xxx)
                绘制矩形: ctx.rect(x,y,dx,dy) ctx.fillRect() ctx.strokRect()
                绘制圆形: ctx.arcTo(x1, y1, x2, y2, r)

                高斯模糊: ctx.drawImage(img, 0, 0, w, h, 0, 0, canvasW, canvasH) // 将图片放到canvas
                         var pixel = ctx.getImageData(0, 0, canvasH, canvasH) // 获取图片像素信息，受到同源策略的限制
                         gaussBlur(pixel); // 高斯模糊
                         ctx.putImageData(pixel, 0, 0); // 将像素信息放回canvas
                         var imageData = canvas.toDataURL(); // 将canvas的内容抽取成一张图片
                         dom.css('background-image', 'url(' + imageData + ')'); // 变成图片的src

        svg: 
             使用svg
             <svg width=“500px” height=“500px”></svg>

             绘制直线: <line x1="xxx" y1="xxx" x2="xxx" y2="xxx"></line>
             绘制矩形: <rect x="xxx" y="xxx" width="xxx" height="xxx" rx="xxx" ry="xxx"″></rect>
             绘制圆形: <circle r="xxx" cx="xxx" cy="xxx"></circle>

             路径: 
                   <path d = "M xxx xxx L xxx xxx" /> 从(xxx,xxx)到(xxx,xxx)
                   <path d="Mxxx xxx H xxx V xxx"/> // H横向移动 V纵向移动
                   A 命令绘制圆弧
                   Z 命令回到起点

        html5获取当前地理位置: window.navigator.geolocation

        html5拖拽: 
                  draggble="true"
                  dragstart 被拖拽元素 开始时触发
                  dragend 被拖拽元素 结束时触发
                  dragenter 目标元素 拖拽元素进入目标元素
                  dragover 目标元素 拖拽元素在目标元素上移动
                  drop 目标元素 被拖拽的元素在目标元素上同时鼠标放开触发的事件

        客户端存储: 
                  localStorage: 存储量在5M以上，浏览器关闭不会失效
                  sessionStorage: 存储量在5M以上，浏览器关闭失效
                  cookie: 存储量不大于4k，过期失效

                  localStorage/sessionStorage
                  操作方法:
                           1.setItem(name,val) 设置属性值
                           2.getItem(name) 获得属性值
                           3.removeItem(name) 移出属性值
                           4.clear() 清除所有属性
                  
                  cookie
                  操作方法:
                           document.cookie = name+"="+value+时间戳 // 存储cookie
                           document.cookie // 查看cookie 用split拆分，返回name对应的value
                           document.cookie = name+"="+""+'-1' // 删除cookie，value值为空，时间戳为-
    </div>

    <div class="css">
        CSS选择器	       权重值
        !important		 无穷大
        行间样式		  1000
        id				  100
        class、属性、伪类	 10
        标签、伪元素		 1
        通配符			   0

        css3选择器:
                   css3属性选择器 ele[attr="*(任意位置),^(开头),$(结尾)"]
                   css3伪类选择器 
                                 :first-of-type
                                 :last-of-type
                                 :nth-of-type(n) 一组中的第几个
                                 :nth-last-of-type(n)
                   css3条件选择器
                                 E+F  F是E的兄弟节点，而且是E后面的第一个
                                 E~F  F是E后面的兄弟节点
                        
        三维动画:
                 首先，设置transform-style: preverse-3d
                 其次，给父级设置景深: transform: prespective(xxx)
                 然后，使用tranform: translateZ(xxx)，形成三维效果

        动画加速: 
                 1.GPU硬件加速模式，让浏览器在渲染动画的时候从CPU转向GPU
                 transform: transtion3d(0,0,0)
                 transform: translateZ(0)
                 2.防止动画出现闪烁
                 backface-visibilty: hidden
                 prespective: xxx

        多列布局: 
                 父级wrapper设置 columns: xxx // 分成几分就写几 
                 column-gap: xxx //  布局两列中间宽度
                 column-rule: 20px solid green // 布局两列中间加一横线
        
        盒子模型:
                 box-sizing: border-box // IE6混杂模式的盒模型 border+padding+content
                 box-sizing: content-box // 标准模式的盒模型 content
                 
        弹性盒子: 
                 父级元素: display: flex
                 子级元素: 
                          flex-grow // 比例分配剩余空间
                          flex-shrink // 按比例收缩超出空间
                          flex-basis // 设置伸缩基准值 相当于width: basis/(basis的总和) * 容器的宽度

                          flex-wrap: no-wrap // 超出部分不换行,会压缩子元素

                  弹性盒子水平垂直居中:
                          justify-content:center
                          align-items:center
    </div>

    <div class="兼容性">
        兼容性:

        opacity兼容性 {
            opacity: 1 // chrome
            filter: alpha(opacity = 100) //ie6~8
            -moz-opacity: 1 // firefox
        }

        浮动模型兼容性 {
            :after {
                display: block;
                content: "";
                clear: both;
            } // chrome

            {
                overflew: hidden;
                _zoom: 1;
            } // ie6~8
        }

        css3属性兼容性 {
            -moz- // firefox         gecko
            -ms- // ie               trident
            -webkit- // safari       webkit
            -o- // opera             presto
            // chrome               blink/webkit
        }
    </div>

    <div class="原型链">
        原型: 原型是function对象的一个属性，它是构造函数制造出来的对象的公共祖先。
              通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。

        func.prototype
        对象.__proto__

        undefined null也都没有原型

        对象查看自身的构造函数: 对象.constructor
                              对象 instanceof 构造函数 --> true

        原型链: 原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。

        继承: 1.原型链继承
              2.构造函数 foo.call()
              3.共享原型 son.prototype = foo.prototype
              4.object.create() 
              5.圣杯模式 
                  var inherit = (function (){
                    var F = function(){};
                    return function (C,P){
                            F.prototype = P.prototype;
                            C.prototype = new F();
                            C.prototype.constructor = C;
                            C.prototype.uber = P;
                    }
                }());
              6.es6 class xxx extands xxx
    </div>

    <div class="闭包">
        作用域: 变量和函数生效的区域。

        作用域链: 函数作用域，函数又可以嵌套，作用域之间就会产生嵌套关系，就产生了作用域链。

        闭包: 闭包就是能够读取其他函数内部变量的函数。(zepto jquery)

        闭包定义: 在一个函数内部再定义一个函数，并且这个内部函数与外部函数的变量有关联，通过返回这个内部的函来访问外部函数里面的变量。

        立即执行函数: 解闭包的一个重要方法，通过另一个新闭包来消除上一个闭包的影响
        (function () {} ())
        (function () {})()
    </div>

    <div class="类型转换">
        基本数据类型: Number，String，Boolean，undefined(未定义)，null(空) 

        原始值: Number，String，Boolean，undefined，null

        引用值: object(array)，function

        默认为false的值: undefined，null，""，NaN，0，false

        typeof的返回值: number，string，boolean，undefined，object，function
    </div>

    <div class="克隆">
        浅层克隆: 源对象里面有什么属性，目标对象就有什么属性。
                 但是当属性是属性是引用值的时候，改变源对象目标对象也会发生改变。
        function clone(src, tar) {
            var tar = tar || {}; 如果没有tar则默认是一个空对象
            for(var prop in src) {
                    if(src.hasOwnProperty(prop)){
                        tar[prop] = src[prop];
                    }
            }
            return tar; 
        }

        深层克隆: 利用递归调用的方法，当检测到源对象里面的这个属性值是引用类型的。
                 就在目标对象里面也创建一个引用类型的属性，是数组就创建数组，是对象就创建对象。
                 将源对象里面的这个引用值和目标对象里面的引用值分别当做新的源对象和目标对象进行克隆。
        function deepCopy(src,tar){
            var tar= tar|| {} ;
            for (var prop in src){
                    if (typeof (src[prop]) == 'object'){
                        tar[prop] = (src[prop].constructor === Array ) ? [] : {};
                        deepCopy(src[prop],tar[prop]);
                    }else {
                        tar[prop] = src[prop];
                    }
            }
            return tar;
        }
    </div>

    <div class="数组去重">
        数组: 可以溢出写，不可以溢出读
        数组上的方法: 
            改变原数组: reverse, // 倒叙
                       sort, // 负数的时候，表示a在前面，b在后面。正数的时候，表示a在后面，b在前面。
                       push,pop, // 后进后出
                       shift,unshift, // 前出前进
                       splice // 删除
            不改变原数组: concat,join
    

        数组去重: 数组中的这个数据出现过一次之后，就在一个对象中将这个元素的值的位置标记成1。
                 后面如果出现相同的属性值，因为这个位置已经是1了，所以就不会添加到新数组里面，从而达到了去重的效果。
        Array.prototype.unique = function () {
            var len = this.length,
            arr = [],
            obj = {};
            for (var i = 0; i < len; i++) {
                    if (!obj[this[i]]) {
                        obj[this[i]] = 1;
                        arr.push(this[i]);
                    }
            }
            return arr;
        }  


        es5数组新方法: foreach(改变原数组)，
                      map(不改变原数组)，
                      filter(不改变原数组)，
                      some，every，
                      reduce，reduceRight

        数组的检测: isArray()方法来检测是否是数组。
                   constructor和instanceof。
                   Object.prototype.toString.call(arr) === ‘[object Array]’ (不会发生窗体混淆)
    </div>
    
    <div class="DOM">
        元素节点——1
        属性节点——2
        文本节点——3
        注释节点——8
        document——9
        DocumentFragment——11

        document.getElementById  // 在ie8以下的浏览器中，不区分大小写，而且标签的name属性也可以被当做id被选择出来
        document.getElementsByClassName // ie8及以下的版本中没有这种方法
        document.getElementsByTagName // 兼容所有浏览器
        document.getElementsByName // 只有部分标签的name可以生效，表单、表单元素、img、iframe
        css选择器: querySelector() // ie7及以下的版本中没有这种方法
                   querySelectorAll() // ie7及以下的版本中没有这种方法


        创建元素节点 document.createElement()
        创建文本节点 document.createTextNode()
        创建注释节点 document.createComment()
        创建文档碎片 document.createDocumentFragment()
        ele.appendChild(child); // 将child插入到ele中的最后
        ele.insertBefore(a,b) // 在父级为ele的元素中，将a插入到b前
        ele.removeChild(child) // 在ele中将child删除
        ele.replaceChild(new,old) // 在ele中用new替换old
        ele.innerHTML // ele中的html结构
        ele.innerText(老火狐不兼容)/ele.textContent(老ie不兼容) // ele中的文本结构
        ele.setAttribute('属性','属性值')
        ele.getAttribute('属性')

        滚动条滚动的距离: document.body.scrollTop, window.pageYOffset 
        视口尺寸: window.innerHeight window.innerwidth, document.body.clientHeight document.body.clientWidth



        获取css样式 {
            ie: dom.currentStyle[属性]
            chrome: window.getComputedStyle(dom,伪元素)[属性]
        }

        绑定事件 {
            ie: attachEvent(,)
            chrome: addEventListener(,,false) // 是否开启事件捕获
            其他: 句柄绑定 onclick
        }
        解除事件 {
            ie: detachEvent(,)
            chrome: addEventListener(,,false)
            其他: onclick = null
        }
        取消冒泡 {
            ie: event.cancelBubble = true
            chrome: event.stopPropagation();
        }
        取消默认事件 {
            ie: e.returnValue = false
            chrome: e.preventDefault()
            其他: return false;
        }

        事件委托 {
            火狐: event.srcElement
            ie: event.target
            chrome: 都支持
        }

        事件处理模型: 先捕获后冒泡(从外向里，从里向外)

        事件处理机制: 1.注册事件
                     2.初始化事件参数
                     3.触发事件（事件捕获 事件执行 事件冒泡）
        
        鼠标事件:                 
                 mousedown, mouseup ,click, // 点击事件先后顺序 (touchstart,touchend,tap) // event.targetTouches[0]
                 mousemove, // 在目标元素上移动 (touchmove)
                 mouseover, mouseout // 移入 移出
                 touchcancel // 停止触摸时触发
                 contextmenu // 右键出现事件

                 e.button e.clientX/e.pageX

        键盘事件: 
                 onkeydown,onkeypress,onkeyup

                 e.keyCode

        滚轮事件: 
                 onscroll

        重绘: 是元素自身的位置和宽高不变,只改变颜色的之类的属性而,不会导致后面的元素位置的变化,渲染树发生重绘
        重排: 是元素自身的位置或者宽高改变了从而导致的整个页面的大范围移动的时候,渲染树发生重排，尽量避免
                  
                 

    </div>

    <div class="BOM">
        window

        navigator.userAgent    前用户使用的是pc端还是移动端，是什么浏览器。

        screen.availHeight/availWidth  可以查看除了window任务栏之外的屏幕的高度和宽度。
        screen.height/width  返回显示器的屏幕的高度和宽度。   兼容的较少。
        screen.deviceXDPI/deviceYDPI  返回显示屏幕的分辨率。

        history.length  浏览历史的长度。
        history.back()  进入到下一个历史页面。
        history.forward()  返回到上一个历史页面。
        history.go()  

        location.host 返回当前的主机名 和 当前的 URL 端口号

        正则表达式: 
                   var reg = /xxx/gim
                   reg.exec(str) // index属性查看比配到的位置
                   str.replace(reg,function($,$1,$2){return xxx})
    </div>

    <div class="网络协议">
        状态码: 
                1xx   信息性状态码

                2xx   成功状态码
                200   请求已经被服务器正常处理
                204   请求处理成功，但是没有资源可以返回。
                206   表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求

                3xx   重定向状态码
                301   永久性重定向
                302   临时性重定向
                303   请求的对应资源存在着另一个URI
                304   资源已找到，但是未符合要求
                307   临时重定向

                4xx   客户端错误状态码
                400   请求报文中存在语法错误
                401   发送的请求需要有通过HTTP认证的认证信息
                403   不允许访问该资源
                404   服务器上没有该资源

                5xx   服务器错误状态码
                500   服务器端在执行请求时发生错误  
                503   服务器暂时处于超负载或正在停机维护，无法处理请求 

        get和post的区别: 
                get                                      post
                主动的或被动的                            主动的
                文本                                     文本或二进制
                小于255个字符                             没有限制
                url的一部分，在浏览器地址中可见            作为请求消息体发送，用户不可见
                数据在url历史缓存中                       数据不在url历史缓存中

        同源策略: 只有在域名、协议名、端口号都相同。
                 不同源的客户端脚本在没有明确授权的情况下，是不能够读写对方的资源的。 

        三次握手: 三次交互，建立连接
                 1.客户单发送 SYN 数据包给服务器
                 2.服务器回传一个 SYN/ACK 数据包
                 3.客户端回传一个 ACK 数据包
        
        四次挥手: 客户端与服务器断开连接
                 1.客户端发送 FIN/ACK 数据包给服务器
                 2.服务器返回 ACK 报文
                 3.服务器与客户端断开连接, 发送 FIN/ACK 报文
                 4.客户端返回一个 ACK 报文, 挥手结束

        URI: 统一资源标识符
        URL: 统一资源定位符

        HTTP协议是TCP/IP协议的子集。
        TCP/IP分层管理的结构是: 应用层、传输层、网络层、数据链路层。
    </div>

    <div class="ajax">
        AJAX最重要的两个对象: 
                             new XMLHttpRequest()
                             new ActiveXObject(‘Microsoft.XMLHTTP’)
        
        AJAX优点:
                  1.页面无刷新
                  2.使用异步的形式与服务器进行通信
                  3.减轻服务器的负担
                  4.不需要插件或者小程序
        AJAX缺点:
                  1.不支持浏览器的后退机制
                  2.对搜索引擎支持较弱
                  3.违背了url和资源定位的初衷支持较弱
        
        AJAX步骤:
                  1.创建ajax对象 
                      XMLHttpRequest();
                      ActiveXObject('Mircosoft.XMLHTTP');

                  2.创建与服务器的连接和调用
                      open(method,get,false) // 第三个参数是否异步
                      send()

                  3.监听对象状态改变
                      readyState == 4 
                      status == 200
                      callBack(responseText);

                  网速非常快，刚刚请求数据，数据就已经返回回来了
                  但是代码还没有走到监听部分，这就导致了监听部分的失效

                  function AJAX(json) {
                     var url = json.url,
                         method = json.method,
                         flag = json.flag,
                         data = json.data,
                         callBack = json.callBack,
                         xhr = null;
                     if(window.XMLHttpRequest) {
                         xhr = new window.XMLHttpRequest();
                     }else {
                         xhr = new ActiveXObject('Mircosoft.XMLHTTP');
                     }			
                     if(method == 'get') {
                         url += '?' + data + new Date().getTime(); 
                         xhr.open('get', url, flag);
                     }else {
                         xhr.open('post', url, flag);
                     }
                     xhr.onreadystatechange = function () {
                         if (xhr.readyState === 4 && xhr.status === 200) {
                             // 数据已经可用了
                             callBack(xhr.responseText);
                         }
                     }
                     if(method == 'get') {
                         xhr.send();
                     }else {
                         xhr.setRequestHeader('Content-Type', 'application/x-www-form-urle');
                         // 设置发送数据的格式
                         xhr.send(data);
                     }	
                 }           
    </div>

    <div class="jsonp">
        跨域的方法: 
                   1.flash
                   2.服务器代理中转
                   3.iframe + document.domain // 主域名相同，子域名不同 document.domain=xxx
                   4.iframe + location.hash // 用hash值传递数据，放到url里
                   5.iframe + window.name
                   6.postMessage //  使用 ifr.contentWindow.postMessage 发送数据
               *** 7.jsonp
        
        jsonp原理: web页面上script标签的src属性引入js文件不受跨域的影响，把资源直接放到script标签的src里面，
                   相当于把数据以json的形式放到服务器上
                   无法监控script的src的加载状态，不知道数据有没有获取完成，所以我们要事先定义好处理函数，
                   这个处理函数就是jsonp

        jsonp实现百度搜索框: 
                   动态创建script标签，src为url地址，将script标签插入到页面中
                   并定义好处理函数，通过解析url地址形参，将数据插入到页面中
                   
        window.onload = function(){
            var $Input = document.getElementById('q');
            var $Ul = document.getElementById('ul1');
            $Input.onkeyup = function(){
                if(this.value != ''){
                    var $Script = document.createElement('script');
                    $Script.src = 'http://suggestion.baidu.com/su?wd=' + this.value + '&cb=doJSON';
                    document.body.appendChild($Script);
                }else{
                    $Ul.style.display = 'none';
                }
            }
        function doJSON(data){
            var $Ul = document.getElementById('ul1');
            var html = '';
            if (data.s.length){
                $Ul.style.display = 'block';
                for(var i = 0; i < data.s.length; i++){
                    html += '<li><a href="https://www.baidu.com/s?wd=' + data.s[i] + '" target="_blank">' + data.s[i] + '</a></li>'
                        } 
                    $Ul.innerHTML = html; 
                }else{ 
                    $Ul.style.display = 'none'; 
                }
        }
    </div>

    <div class="webpack">
        Webpack 是一个 CommonJs 和 AMD 模块打包器


        var webpack = require('webpack'); // 引入webpack模块
        module.exports = { // 配置模块
            entry: './src/js/index.js', // 打包入口文件,一个对象或者一个字符串
            output: { // 配置打包结果，一个对象
                path: './build/', // 输出文件路径
                filename: 'build.js' // 输出文件名字
            },
            module: { // 模块的处理逻辑
                loaders: [ // 一系列加载器，一个数组
                    {
                        test: /\.js$/, // 正则表达式，匹配文件
                        loader: 'babel-loader', // 加载器
                    },
                    {
                        test: /\.css$/,
                        loader: ['css-loader','style-loader']
                    },
                    {
                        test: /\.less$/,
                        loader: ['less-loader','css-loader','style-loader']
                    },
                    {
                        test: /\.(jpg|png|gif)$/,
                        loader: 'url-loader?limit=8192',
                    }
                ],
                resolve: { // 对模块的解析
                    extensions: ['','.js','.css','.less','.json'] // 自动补全识别的后缀
                },
                plugins: [ // 定义拆件，一个数组
                    new webpack.ProvidePlugin({ // 引入拆件模块
                        $: 'jquery',
                        jQuery: 'jquery'
                    })
                ]
            }
        }
    </div>

    <div class="模块化">
        webpack就是遵循commonjs开发的
        commonjs: 
                  1.定义模块 
                  一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性
                  2.模块输出
                  模块只有一个出口，module.exports对象，把模块要输出的内容放入该对象
                  3、加载模快
                  加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象

        AMD: 异步模块定义(浏览器开发模块的一种规范)
             AMD就是RequireJS在推广过程中定义出的规范

             requireJS解决了:
                        1.多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 
                        2.js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长
             requireJS:
                        1.define用来定义模块
                        define(['当前模块依赖的模块名称数组'],function(){})
                        2.require用来加载模块
                        require(['所依赖的模块'],function(){})
        
        CMD: 通用模块定义(浏览器开发模块的一种规范)
             CMD就是SeaJS在推广过程中定义出的规范

             SeaJS解决的问题和requireJS类似，在模块定义方式和模块加载时机上有所不同 

             SeaJs: 
                    1.define用来定义模块
                    define(function(require, exports, module){})
                    2.seajs用来加载模块
                    seajs.use(['所依赖的模块'],function(){})

        AMD与CMD的区别:
                       1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 
                       2、CMD推崇就近依赖，只有在用到某个模块的时候再去require 
    </div>

    <div class="less sass">
        less与sass的区别:
            1.LESS是基于JavaScript运行,所以LESS是在客户端处
            2.Sass是基于Ruby运行，是在服务器端处理

        less运行:
            1.下载一个你要的less.js脚本
            2.创建一个文件来放置你的样式,index.less
            3.添加到html head中

        less与sass的优点和共性: 
            1.混入————class中的class
            2.参数混入————可以传递参数的class，就像函数一样
                .border-radius( @radius: 3px ) {
                    -webkit-border-radius: @radius;
                    -moz-border-radius: @radius;
                    border-radius: @radius;
                }
            3.嵌套规则————Class中嵌套class，从而减少重复的代码
            4.运算————CSS中用上数学
                @base_margin: 10px;
                @double_margin: @base_margin * 2;
            5.颜色功能————可以编辑颜色
                @blue: #00c;  
                @light_blue: @blue + #333;  
                @dark_blue: @blue - #333; 
            6.名字空间————分组样式，从而可以被调用
                自己组中定义的自己调用，别的组调用不了
            7.作用域————局部修改样式
                @color: #00c; /* 蓝色 */
                #header {
                    @color: #c00; /* 红色 */
                    border: 1px solid @color; /* 红色边框 */
                }
            8.JavaScript赋值————在CSS中使用JavaScript表达式赋值
                @height = 'document.body.clientHeight';
    </div>

    <div class="git">
        git分布式版本控制器
        git常见指令

        1.远成仓库命令:
            检出仓库：$ git clone git://github.com/jquery/jquery.git
            查看远程仓库：$ git remote -v
            添加远程仓库：$ git remote add [name] [url]
            删除远程仓库：$ git remote rm [name]
            拉取远程仓库：$ git pull [remoteName] [localBranchName]
            推送远程仓库：$ git push [remoteName] [localBranchName]

        2.分支(branch)操作命令:
            查看本地分支：$ git branch
            查看远程分支：$ git branch -r
            创建本地分支：$ git branch [name]
            切换分支：$ git checkout [name]
            创建新分支并立即切换到新分支：$ git checkout -b [name]
            删除分支：$ git branch -d [name] 
            合并分支：$ git merge [name]

        git commit 提交 
        git init   git仓库库初始化
    </div>

    <div class="github">
        登录github建立存储库
        点击public并点击Initialize this repository with a README
        这么建立就有README了

        建立一个文件夹，打开git

        第一步
        ssh -T git@github.com

        第二步 克隆代码
        git clone https://github.com/duanran1996/duanran_test.git
        建立完仓库自动生成的网址

        第三部 上传
        进入duanran_test文件夹

        若没有README
        git init
        touch README.md
        git add README.md
        git commit -m 'first_commit'             first_commit为新建的一个为文件夹，名字随意，里面有html页面
        git remote add origin https://github.com/findingsea/myRepoForBlog.git
        git push origin master

        若有README
        git add .
        git commit -m 'first_commit'             first_commit为新建的一个为文件夹，名字随意，里面有html页面
        git remote add origin https://github.com/findingsea/myRepoForBlog.git
        git push origin master

        若执行git remote add origin https://github.com/findingsea/myRepoForBlog.git出现:
        fatal: remote origin already exists
        在命令行输入: git remote rm origin

        若执行git push origin master出现:
        error:failed to push som refs to.......
        在命令行输入: git pull origin master
    </div>

    <div class="媒体查询 响应式布局">
        @media screen and ... {}
        彩屏设备和...

        @media only screen and ... {}
        仅限彩屏设备和...

        @media (min-width: 100px) and (max-width: 200px) {}
        宽度为100~200px之间的设备

        实现响应式布局:
                      1. meta标签name=viewpoint禁止用户缩放;
                      2. html{font-size: 62.5%} 使用rem;
                      3. 宽度百分比，高度自适应，背景图片被撑开;
                      4. media query适配各种不同的设备;
    </div>

    <div class="es6">
        es6新功能: 
                  1.let 和 const:
                                  let产生一个块级作用域 const是不可改变的常量
                  2.解构赋值:
                             var {a,b} = {b:'234',a:123};
                             ... 扩展运算符
                  3.字符串: 
                           `${}` 模板字符串
                    数组: 
                          Array.from() 将类数组转化为真正的数组
                          Array.of(xx,xx,xx) 将一组数值转化成数组
                    对象: 
                          obj[xxx] 新增括号方式
                          object.is(xxx,xxx) 判断是否相等 
                          object.assign({},xxx,xxx) 用于对象合并
                    函数:
                          实参传递默认值
                          => 箭头函数  形参=>返回值 没有this不可以用作构造函数
                  4.class:
                           class xxx {}
                           constructor() {this.xxx = xxx} 在contructor中定义属性 
                           class A extends B   A继承B, 也可在A中constructor中用super(xxx,xxx)调用父级constructor属性, 用super.xxx() 调用父级方法
                           
                  5.set 与 map 新结构
                  6.promise

        Promise:
                 Promise是异步编程的一种解决方案

                 特点:
                      1.对象的状态不受外界影响
                      2.一旦状态改变，就不会再变

                 promise对象有三种状态
                 Pending(进行中) Resolved(成功) Rejected(失败)

                 Pending ——> Resolved
                 Pending ——> Rejected

                 Promise对象是一个构造函数,接受一个函数作为参数，这个函数的两个参数分别是resolve和reject
                 resolve: 是将promise从Pending ——> Resolved
                 reject: 是将promise从Pending ——> Rejected

                 var promise = new Promise(function(resolve, reject) {
                     if (/* 异步操作成功 */){
                         resolve(value);
                     } else {
                         reject(error);
                     }
                 });

                 promise.then指定Resolved状态和Reject状态的回调函数,这个方法可以接受两个回调函数作为参数
                 第一个回调函数是Promise对象的状态变为Resolved时调用
                 第二个回调函数是Promise对象的状态变成Rejected时调用。

                 promise.all 和 promise.race 将多个promise实例包装成一个promise实例
                 all为都成功promise状态成功
                 race为有一个成功promise状态成功
    </div>

    <div class="react">
        react.js
        react-dom.js
        browser.min.js

        jsx语法 babel转码器
        <> html语法
        {} js语法

        使用react:
                  var App = react.createClass({
                      render: function () {
                          return ()
                      }
                  })
                  const App extend react.component({
                      render() {
                          return ()
                      }
                  })

        渲染到页面上:
                     reactDom.render({
                         <App/>,
                         document.body
                     })

        react优点: 
                   1.diff算法，虚拟dom
                   在componentDidMount生命周期中用this.refs.div1获取到虚拟dom
                   <div ref="div1"/>

                   2.单项数据流
                   在render中可以用this.props.data获取到从外向里传入的数据
                   <div data={data}/>
                   使用this.props.children很方便操纵子节点

                   3.组件化
                   一个功能为一个组件，便于团队化开发，更可以配合前段工程化工具开发
                   <div>
                       <Add/>
                       <Sub/>
                   </div>

                   4.方便的引入类库，配合ajax获取数据进行开发
                   在componentDidMount生命周期中实现

                   5.可以方便的与用户进行互动
                   在getInitialState中return一个值，在进行dom操作的时候用this.setState改变这个值

                   6.提供了一些现成的方法
                   如map方法，获取到数据直接进行操作，很方便
                   React.Children.map                       
    </div>

    <div class="redux">
        什么时候使用redux: 
                          1.用户的使用方式复杂
                          2.不同身份的用户有不同的使用方式（比如普通用户和管理员）
                          3.多个用户之间可以协作
                          4.与服务器大量交互，或者使用了WebSocket
                          5.View要从多个来源获取数据
        
        redux 通过引入createStore，使用createStore方法和reducer创建store

        redux工作流程:
                      1.用户发出 Action，store.dispatch(action)

                          Action 就是 View 发出的通知，表示 State 应该要发生变化了
                          Action 是一个对象。其中的type属性是必须的，表示 Action 的名称
                          const action = {
                              type: 'ADD_TODO',
                          };
                          store.dispatch()是 View 发出 Action 的唯一方法

                      2.Store 自动调用 Reducer，并且传入两个参数: 当前 State 和收到的 Action，Reducer 会返回新的 State

                          state就是Store对象包含所有数据
                          Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State

                      3.State 一旦有变化，Store 就会调用监听函数，store.subscribe(listener)

                          Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数

                      4.listener通过store.getState()得到当前状态,重新渲染view层

        redux累加器: 
            <script type="text/babel">
                const reducer = (state = 0, action) => {
                    switch (action.type) {
                        case 'ADD': 
                            return state + 1;
                        case 'SUB': 
                            return state - 1;
                        default: return state;
                    }
                };
                const store = Redux.createStore(reducer);
                class Counter extends React.Component{
                    render() {
                        return (
                            <div>
                                <h1>{this.props.value}</h1>
                                <button onClick={this.props.onAdd}>+</button>
                                <button onClick={this.props.onSub}>-</button>
                            </div>
                        )
                    }
                }
                const render = () => {
                    ReactDOM.render(
                        <Counter
                            value={store.getState()}
                            onAdd={() => store.dispatch({
                                type: 'ADD'
                            })}
                            onSub={() => store.dispatch({
                                type: 'SUB'
                            })}
                        />,
                        document.getElementById('root')
                    );
                };
                render();
                store.subscribe(render);  
            </script>  
    </div>

    <div class="nodejs">
        事件模块:
                 const events = require('events');
                 const event1 = new events();

                 绑定事件: event1.on('xxx',function(){})
                 绑定一次: event1.once('xxx',function(){})
                 触发事件: event1.emit('xxx')
                 删除事件: event1.removeListener('xxx',function(){})
                 添加到事件头部队列: event1.prependListener('xxx',function(){})
                 添加到一次事件头部队列: event1.prependOnceListener('xxx',function(){})

        文件管理: 
                 const fs = require('fs')
                 读文件: fs.readFile('文件','编码格式','回调函数function(err,data){}')
                 写文件: fs.writeFile('文件','数据','编码格式','回调函数function(err){}')

                 同步读取文件夹: let data = fs.readdirSync('路径','编码格式')
                 异步读取文件夹: fs.readdir('路径','编码格式','回调函数function(err,data)')
                 判断是不是文件夹: isDirectory()

                 深度遍历使用同步的方法递归调用，广度遍历使用异步的方法递归调用

                 读取流操作: let rs = fs.createReadStream('路径','读取方式，可以是一个对象')
                 写入流操作: let ws = fs.createWriteStream('路径','写入方式，可以是一个对象')
                            ws.write() 写入的东西

                 文件监听: fs.watch();
        
        网络操作: 
                 const http = require('http')
                 使用var server = http.createServer(function(request,response){})创建一个服务器
                 使用server.listen('端口号')用来监听

                 客户端发送的请求为request:
                     1.request.headers      请求头
                     2.request.url          请求路径
                     3.request.method       请求方法
                     4.requset.httpVersion  http协议的版本

                     请求主体的事件需要触发 requset.on('data',function(data){}) 来监听
                     例如post发送的内容就在请求主体，可以用 decodeURIComponent(data) 获取

                     请求结束的时候自动调用 request.on('end',function(){})

                服务端发出的请求为response:
                    1.response.end               用于声明整个请求已经发送完毕，每个响应必须调用一次，否则不结束网页会卡死
                    2.response.write             用于往请求主体汇总写入数据，而且调用这个方法后，响应头以及响应行也不能再操作了
                    3.response.statusCode        可以操作响应状态码
                    4.response.statusMessage     可操作响应状态信息
                    5.response.setHeader         设置http响应头的信息
                    6.response.writeHeader       向客户端发送一个响应头，一个请求内最多只能调用一次

                        response.writeHeader('状态码','关联数组对象，响应头的每一个属性')

                        response.writeHeader('200',{
                            'Content-Length': 'body.length',
                            'Content-Type': 'text/plain'
                        }) // 成功

                        response.writeHeader('302',{
                            'Location': 'xxx',
                        }) // 重定向


        const http = require('http');
        const fs = require('fs');
        var message;
        fs.readFile('./data.json', 'utf-8', function (err, data) {
            if(err) {
                console.log(err);
                return ;
            }
            message = JSON.parse(data).message;
        })
        const server = http.createServer(function (req, res) {
            var user = ''
            req.on('data', function (data) {
                user = decodeURIComponent(data)
            })
            req.on('end', function () {
                var userArr = user.split('&');
                var useMes = [];
                for(var i = 0 ; i < userArr.length ; i++) {
                    useMes[i] = userArr[i].split('=')[1];
                }
                res.setHeader('Content-Type', 'text/html');
                for(var i = 0 ; i < message.length ; i++) {
                    if(useMes[0] == message[i].name && useMes[1] == message[i].pas) {
                        res.writeHead(302, {
                            'Location': 'http://www.taobao.com'
                        });
                        res.end();
                    }
                    else {
                        if(i == message.length - 1) {
                            res.writeHead(302, {
                                'Location': 'http://www.baidu.com'
                            });
                            res.end();  
                        }
                    }
                }       
            })
        })
        server.listen(3000);
        console.log('server is running');
    </div>

    <div class="网络性能呢优化 CSRF XSS">
        性能优化:
                 页面级优化
                    1.减少HTTP请求数
                        * 从设计实现层面简化页面
                        * 合理设置HTTP缓存
                        * 资源合并与压缩 js,css,img 都可以用压缩软件进行压缩
                        * css雪碧图, 切图的时候将一些icon放到一个图片资源中, 然后通过改变位置来获取需要的图片
                        * 瀑布流, HTTP请求数是不变的, 他只是可以减少页面刚加载的时候的HTTP请求数
                    2.将外部js脚本放在底部, 因为js脚本会阻塞其他的资源加载
                    3.异步加载js
                    4.懒加载, 在需要资源的时候才加载资源
                    5.将CSS放到Head中, 防止加载不出来css样式
                    6.减少不必要的HTTP跳转
                    7.避免重复的资源请求    
                    8.合理的使用图片预加载, 提升页面效果
                
                 代码级优化
                    1.DOM
                        * domready, 在页面所有dom加载完成后, 在进行js操作
                        * 减少重绘和重排
                    2.少使用with with会改变作用域链, 有可能导致我们的作用域链变长, 导致查询性能下降
                    3.减少作用域链查找, 尽量使用本作用域的变量
                    4.使用精简的算法减少时间复杂度


        CSRF: 跨站点伪装请求
              CSRF请求可以直接通过我们登录状态，来伪造一个请求

              预防措施: 在请求中加入随机数，让钓鱼网站无法正常伪造请求

        XSS: 跨站点攻击
             设法获取网站的cookie，通过cookie获取session，来登录网站搞破坏

             预防措施: 
                      XSS一般是通过写入html的标签或者js代码，来获取cookie信息的 
                      将用户输入语句中的"javascript","jscript","vbscript",都用空白代替
                      过滤和转换掉 "<" ">"，让攻击者无法构造HTML标记
                    

        CSEF与XSS区别: CSRF不需要js代码，只需要发送一个get或者post请求
    </div>

    <div class="else">
        优雅降级: 一开始就构建站点的完整功能，然后针对浏览器测试和修复。
        渐进增强: 一开始只构建站点的最少特性，然后不断针对各浏览器追加功能。

        a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给;
        b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要;
        c. 降级意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带;

        websocket: WebSocket是与与http协议一样都基于TCP协议的
                   WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的
                   能更好的节省服务器资源和带宽并达到实时通讯
                   WebSocket协议的URL使用ws://开头，另外安全的WebSocket协议使用wss://开头

                   var wsUri ="ws://echo.websocket.org/"
                   websocket = new WebSocket(wsUri) // 参数是需要连接的服务器端的地址

                   当Browser和WebSocketServer连接成功后，会触发onopen消息
                   websocket.onopen = function(event) {}

                   如果连接失败，发送、接收数据失败或者处理数据出现错误，会触发onerror消息
                   websocket.onerror = function(event) {}

                   当Browser接收到WebSocketServer发送过来的数据时，就会触发onmessage消息，参数中包含传输过来的数据
                   websocket.onmessage = function(event) {}

                   当Browser接收到WebSocketServer端发送的关闭连接请求时，就会触发onclose消息
                   websocket.onclose = function(event) {}
    </div>
</body>
</html>
